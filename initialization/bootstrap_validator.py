# initialization/bootstrap_validator.py
"""Bootstrap result validation for ensuring complete, valid initialization data."""

from typing import Any, TYPE_CHECKING
import structlog

# Types available for type checking only
if TYPE_CHECKING:
    from processing.state_tracker import StateTracker

logger = structlog.get_logger(__name__)


class BootstrapValidationResult:
    """Result of bootstrap validation with detailed feedback."""
    
    def __init__(self):
        self.is_valid: bool = True
        self.errors: list[str] = []
        self.warnings: list[str] = []
        self.validation_details: dict[str, Any] = {}
    
    def add_error(self, message: str) -> None:
        """Add a validation error."""
        self.errors.append(message)
        self.is_valid = False
        logger.error(f"Bootstrap validation error: {message}")
    
    def add_warning(self, message: str) -> None:
        """Add a validation warning."""
        self.warnings.append(message)
        logger.warning(f"Bootstrap validation warning: {message}")
    
    def add_detail(self, key: str, value: Any) -> None:
        """Add validation detail."""
        self.validation_details[key] = value


async def validate_bootstrap_results(
    plot_outline: dict[str, Any],
    character_profiles: dict[str, Any],
    world_building: dict[str, dict[str, Any]],
    state_tracker: "StateTracker | None" = None,
) -> BootstrapValidationResult:
    """Validate that bootstrap process created complete, valid data.
    
    Args:
        plot_outline: The bootstrapped plot outline
        character_profiles: The bootstrapped character profiles
        world_building: The bootstrapped world building elements
        state_tracker: Optional StateTracker for checking duplicates and conflicts
        
    Returns:
        BootstrapValidationResult with validation status and details
    """
    result = BootstrapValidationResult()
    
    logger.info("Starting bootstrap result validation...")
    
    # Validate plot outline
    await _validate_plot_outline(plot_outline, result)
    
    # Validate character profiles
    await _validate_character_profiles(character_profiles, result, state_tracker)
    
    # Validate world building elements
    await _validate_world_building(world_building, result, state_tracker)
    
    # Validate cross-references and consistency
    await _validate_consistency(plot_outline, character_profiles, world_building, result)
    
    # Add summary details
    result.add_detail("total_characters", len(character_profiles))
    result.add_detail("total_world_categories", len(world_building))
    result.add_detail("total_world_items", sum(len(items) for items in world_building.values() if isinstance(items, dict)))
    
    if result.is_valid:
        logger.info("Bootstrap validation passed successfully")
    else:
        logger.error(f"Bootstrap validation failed with {len(result.errors)} errors")
    
    return result


async def _validate_plot_outline(plot_outline: dict[str, Any], result: BootstrapValidationResult) -> None:
    """Validate plot outline structure and required fields."""
    
    # Core required fields for plot outline
    required_fields = [
        "title",
        "protagonist_name", 
        "summary"  # Should always be generated by bootstrap
    ]
    
    # Important fields that should usually be present
    important_fields = [
        "genre", 
        "setting"
    ]
    
    # Check required fields are present and not empty
    for field in required_fields:
        if field not in plot_outline:
            result.add_error(f"Plot outline missing required field: {field}")
        elif not plot_outline[field] or str(plot_outline[field]).strip() == "":
            result.add_error(f"Plot outline field '{field}' is empty")
        elif _is_fill_in_placeholder(plot_outline[field]):
            result.add_error(f"Plot outline field '{field}' contains placeholder value: {plot_outline[field]}")
    
    # Check important fields as warnings
    for field in important_fields:
        if field not in plot_outline:
            result.add_warning(f"Plot outline missing important field: {field}")
        elif not plot_outline[field] or str(plot_outline[field]).strip() == "":
            result.add_warning(f"Plot outline field '{field}' is empty")
        elif _is_fill_in_placeholder(plot_outline[field]):
            result.add_warning(f"Plot outline field '{field}' contains placeholder value: {plot_outline[field]}")
    
    # Validate protagonist name is reasonable
    protagonist_name = plot_outline.get("protagonist_name", "")
    if protagonist_name and len(protagonist_name.strip()) < 2:
        result.add_warning(f"Protagonist name seems too short: '{protagonist_name}'")
    
    # Validate summary is substantial
    summary = plot_outline.get("summary", "")
    if summary and len(summary.strip()) < 50:
        result.add_warning(f"Plot summary seems too short ({len(summary)} chars). Consider expanding.")
    
    # Check for optional but recommended fields (only warn if completely missing)
    recommended_fields = ["themes", "tone"]  # Reduced list to avoid too many warnings
    missing_recommended = [field for field in recommended_fields if field not in plot_outline]
    if missing_recommended:
        result.add_warning(f"Plot outline missing optional recommended fields: {', '.join(missing_recommended)}")
    
    result.add_detail("plot_outline_fields", list(plot_outline.keys()))


async def _validate_character_profiles(
    character_profiles: dict[str, Any], 
    result: BootstrapValidationResult,
    state_tracker: "StateTracker | None" = None
) -> None:
    """Validate character profiles structure and content."""
    
    if not character_profiles:
        result.add_error("No character profiles found")
        return
    
    # Check minimum number of characters
    if len(character_profiles) < 2:
        result.add_warning(f"Only {len(character_profiles)} character(s) found. Stories typically need at least 2-3 characters.")
    
    # NEW: Check for duplicate names across all character profiles
    await _validate_character_uniqueness(character_profiles, result, state_tracker)
    
    protagonist_found = False
    antagonist_found = False
    
    for name, profile in character_profiles.items():
        # Validate basic profile structure
        if not name or name.strip() == "":
            result.add_error("Character profile has empty name")
            continue
            
        # Handle both dict and object access patterns for description
        if hasattr(profile, 'description'):
            description = profile.description
        else:
            description = profile.get("description", "")
            
        if not description or description.strip() == "":
            result.add_error(f"Character '{name}' has empty description")
        
        if len(description.strip()) < 20:
            result.add_warning(f"Character '{name}' has very short description ({len(description)} chars)")
        
        # Check for placeholder names
        if _is_fill_in_placeholder(name):
            result.add_error(f"Character has placeholder name: '{name}'")
        
        # Check role assignments (handle both dict and object access patterns)
        if hasattr(profile, 'updates'):
            role = profile.updates.get("role", "unknown")
        else:
            role = profile.get("role", profile.get("updates", {}).get("role", "unknown"))
        
        if role == "protagonist":
            protagonist_found = True
        elif role == "antagonist":
            antagonist_found = True
        
        # Validate traits exist (handle both dict and object access patterns)
        if hasattr(profile, 'traits'):
            traits = profile.traits
        else:
            traits = profile.get("traits", [])
            
        if not traits:
            result.add_warning(f"Character '{name}' has no traits defined")
        elif len(traits) < 2:
            result.add_warning(f"Character '{name}' has only {len(traits)} trait(s). Consider adding more.")
        
        # Check for placeholder content in traits
        for trait in traits:
            if _is_fill_in_placeholder(trait):
                result.add_warning(f"Character '{name}' has placeholder trait: '{trait}'")
        
        # StateTracker validation - check for type/description conflicts
        if state_tracker:
            metadata = await state_tracker.check(name)
            if metadata:
                if metadata["type"] != "character":
                    result.add_error(f"Type conflict for '{name}': StateTracker shows type '{metadata['type']}' but validating as character")
                
                # Check for description similarity conflicts  
                similar_name = await state_tracker.has_similar_description(description, "character")
                if similar_name and similar_name != name:
                    result.add_warning(f"Character '{name}' has description similar to '{similar_name}'")
            else:
                # Character not found in StateTracker - this could indicate it wasn't properly reserved
                result.add_warning(f"Character '{name}' not found in StateTracker - may indicate incomplete reservation process")
    
    # Validate story structure requirements
    if not protagonist_found:
        result.add_error("No protagonist character found. Every story needs a protagonist.")
    
    if not antagonist_found:
        result.add_warning("No antagonist character found. Most stories benefit from a clear antagonist.")
    
    result.add_detail("character_roles", [
        (profile.updates.get("role", "unknown") if hasattr(profile, 'updates') 
         else profile.get("role", profile.get("updates", {}).get("role", "unknown")))
        for profile in character_profiles.values()
    ])


async def _validate_character_uniqueness(
    character_profiles: dict[str, Any], 
    result: BootstrapValidationResult,
    state_tracker: "StateTracker | None" = None
) -> None:
    """Check for duplicate names across all character profiles and validate against StateTracker."""
    if not character_profiles:
        return
    
    # Check for duplicate names in the profile set itself
    name_counts = {}
    for name in character_profiles.keys():
        if name:  # Skip empty names
            name_counts[name] = name_counts.get(name, 0) + 1
    
    duplicate_names = [name for name, count in name_counts.items() if count > 1]
    for name in duplicate_names:
        result.add_error(f"Duplicate character name found: '{name}' appears {name_counts[name]} times")
    
    # Cross-check with StateTracker for consistency and additional validation
    if state_tracker:
        tracked_entities = await state_tracker.get_entities_by_type("character")
        tracked_names = set(tracked_entities.keys())
        profile_names = set(character_profiles.keys())
        
        # Check for names in profiles but not tracked
        untracked_names = profile_names - tracked_names
        for name in untracked_names:
            result.add_warning(f"Character '{name}' exists in profiles but not tracked in StateTracker")
        
        # Check for tracked names not in profiles (potential inconsistency)
        extra_tracked = tracked_names - profile_names
        for name in extra_tracked:
            result.add_warning(f"Character '{name}' tracked in StateTracker but not in profiles")
        
        # Check for duplicate names in StateTracker that might not be caught by profile validation
        # This handles edge cases where StateTracker might have conflicts not reflected in profiles
        tracked_name_counts = {}
        for name in tracked_names:
            tracked_name_counts[name] = tracked_name_counts.get(name, 0) + 1
        
        tracked_duplicates = [name for name, count in tracked_name_counts.items() if count > 1]
        for name in tracked_duplicates:
            result.add_error(f"StateTracker duplicate character name found: '{name}' appears {tracked_name_counts[name]} times")


async def _validate_world_building(
    world_building: dict[str, dict[str, Any]], 
    result: BootstrapValidationResult,
    state_tracker: "StateTracker | None" = None
) -> None:
    """Validate world building elements structure and content."""
    
    if not world_building:
        result.add_error("No world building elements found")
        return
    
    # Filter out metadata keys
    world_categories = {
        k: v for k, v in world_building.items() 
        if k not in ["is_default", "source"] and isinstance(v, dict)
    }
    
    if not world_categories:
        result.add_error("No valid world building categories found")
        return
    
    # NEW: Check for duplicate names across all world building categories
    await _validate_world_uniqueness(world_categories, result, state_tracker)
    
    total_items = 0
    
    for category, items in world_categories.items():
        if not items:
            result.add_warning(f"World category '{category}' has no items")
            continue
        
        category_item_count = 0
        for item_name, item in items.items():
            # Handle both object and dict patterns
            if hasattr(item, 'name'):
                # WorldItem object
                item_name_val = item.name
                item_description = item.description
            else:
                # Dictionary representation
                item_name_val = item.get("name", item_name)
                item_description = item.get("description", "")
            
            # Validate item structure
            if not item_name_val or item_name_val.strip() == "":
                result.add_error(f"World item in category '{category}' has empty name")
                continue
            
            if _is_fill_in_placeholder(item_name_val):
                result.add_error(f"World item has placeholder name: '{item_name_val}' in category '{category}'")
            
            if not item_description or item_description.strip() == "":
                result.add_warning(f"World item '{item_name_val}' in category '{category}' has empty description")
            elif len(item_description.strip()) < 20:
                result.add_warning(f"World item '{item_name_val}' in category '{category}' has very short description ({len(item_description)} chars)")
            
            # Check for placeholder content in description
            if _is_fill_in_placeholder(item_description):
                result.add_warning(f"World item '{item_name_val}' has placeholder description")
            
            # StateTracker validation - check for type/description conflicts
            if state_tracker:
                metadata = await state_tracker.check(item_name_val)
                if metadata:
                    if metadata["type"] != "world_item":
                        result.add_error(f"Type conflict for '{item_name_val}': StateTracker shows type '{metadata['type']}' but validating as world_item")
                    
                    # Check for description similarity conflicts  
                    similar_name = await state_tracker.has_similar_description(item_description, "world_item")
                    if similar_name and similar_name != item_name_val:
                        result.add_warning(f"World item '{item_name_val}' has description similar to '{similar_name}'")
                else:
                    # World item not found in StateTracker - this could indicate it wasn't properly reserved
                    result.add_warning(f"World item '{item_name_val}' not found in StateTracker - may indicate incomplete reservation process")
            
            category_item_count += 1
        
        total_items += category_item_count
        result.add_detail(f"world_category_{category}_count", category_item_count)
    
    # Validate minimum world complexity
    if total_items < 5:
        result.add_warning(f"Only {total_items} world items found. Rich stories benefit from more detailed world-building.")
    
    # Check for important world categories (only warn about key missing ones)
    key_categories = ["locations", "factions"]
    missing_key = [cat for cat in key_categories if cat not in world_categories or not world_categories[cat]]
    if missing_key:
        result.add_warning(f"Missing key world building categories: {', '.join(missing_key)}. Consider adding for richer storytelling.")
    
    # Optional categories - only mention if none are present
    optional_categories = ["cultures", "religions", "governments"]
    missing_optional = [cat for cat in optional_categories if cat not in world_categories or not world_categories[cat]]
    if len(missing_optional) == len(optional_categories):  # Only warn if ALL are missing
        result.add_warning("No cultural/religious/governmental elements found. Consider adding some for world depth.")
    
    result.add_detail("world_categories", list(world_categories.keys()))


async def _validate_world_uniqueness(
    world_categories: dict[str, Any], 
    result: BootstrapValidationResult,
    state_tracker: "StateTracker | None" = None
) -> None:
    """Check for duplicate names across all world building categories and validate against StateTracker."""
    if not world_categories:
        return
    
    # Check for duplicate names across all categories
    all_item_names = []
    category_mapping = {}  # Maps item names to their categories
    
    for category, items in world_categories.items():
        if not isinstance(items, dict):
            continue
        for item_name, item in items.items():
            # Handle both object and dict patterns
            if hasattr(item, 'name'):
                item_name_val = item.name
            else:
                item_name_val = item.get("name", item_name)
            
            if item_name_val:
                all_item_names.append(item_name_val)
                category_mapping[item_name_val] = category
    
    # Check for duplicates in the profile set itself
    name_counts = {}
    for name in all_item_names:
        name_counts[name] = name_counts.get(name, 0) + 1
    
    duplicate_names = [name for name, count in name_counts.items() if count > 1]
    for name in duplicate_names:
        categories_with_name = [cat for item_name, cat in category_mapping.items() if item_name == name]
        result.add_error(f"Duplicate world item name found: '{name}' appears in categories {categories_with_name}")
    
    # Cross-check with StateTracker for consistency and additional validation
    if state_tracker:
        tracked_entities = await state_tracker.get_entities_by_type("world_item")
        tracked_names = set(tracked_entities.keys())
        profile_names = set(all_item_names)
        
        # Check for names in profiles but not tracked
        untracked_names = profile_names - tracked_names
        for name in untracked_names:
            result.add_warning(f"World item '{name}' exists in profiles but not tracked in StateTracker")
        
        # Check for tracked names not in profiles (potential inconsistency)
        extra_tracked = tracked_names - profile_names
        for name in extra_tracked:
            result.add_warning(f"World item '{name}' tracked in StateTracker but not in profiles")
        
        # Check for duplicate names in StateTracker that might not be caught by profile validation
        tracked_name_counts = {}
        for name in tracked_names:
            tracked_name_counts[name] = tracked_name_counts.get(name, 0) + 1
        
        tracked_duplicates = [name for name, count in tracked_name_counts.items() if count > 1]
        for name in tracked_duplicates:
            result.add_error(f"StateTracker duplicate world item name found: '{name}' appears {tracked_name_counts[name]} times")


async def _validate_consistency(
    plot_outline: dict[str, Any], 
    character_profiles: dict[str, Any], 
    world_building: dict[str, dict[str, Any]],
    result: BootstrapValidationResult
) -> None:
    """Validate consistency between plot, characters, and world elements."""
    
    # Check protagonist name consistency
    plot_protagonist = plot_outline.get("protagonist_name", "")
    protagonist_in_profiles = any(
        (profile.updates.get("role") if hasattr(profile, 'updates')
         else profile.get("role", profile.get("updates", {}).get("role"))) == "protagonist"
        for profile in character_profiles.values()
    )
    
    if plot_protagonist and plot_protagonist not in character_profiles:
        result.add_error(f"Plot protagonist '{plot_protagonist}' not found in character profiles")
    
    if plot_protagonist and not protagonist_in_profiles:
        result.add_error("Plot has protagonist name but no character profile has 'protagonist' role")
    
    # Check setting consistency
    plot_setting = plot_outline.get("setting", "")
    has_locations = "locations" in world_building and world_building["locations"]
    
    if plot_setting and not has_locations:
        result.add_warning("Plot mentions setting but no locations found in world building")
    
    # Check genre-world consistency
    genre = plot_outline.get("genre", "").lower()
    world_categories = [k for k in world_building.keys() if k not in ["is_default", "source"]]
    
    if "fantasy" in genre:
        fantasy_categories = ["magic_systems", "creatures", "religions"]
        if not any(cat in world_categories for cat in fantasy_categories):
            result.add_warning("Fantasy genre specified but no fantasy-specific world elements found")
    
    if "sci-fi" in genre or "science fiction" in genre:
        scifi_categories = ["technology", "alien_species", "governments", "factions"]
        if not any(cat in world_categories for cat in scifi_categories):
            result.add_warning("Sci-fi genre specified but no sci-fi-specific world elements found")
    
    # Validate character count matches story complexity
    story_complexity = len(world_categories) + len(str(plot_outline.get("summary", ""))) // 100
    character_count = len(character_profiles)
    
    if story_complexity > 5 and character_count < 3:
        result.add_warning(f"Complex world ({story_complexity} complexity score) but only {character_count} characters. Consider adding more characters.")


def _is_fill_in_placeholder(value: Any) -> bool:
    """Check if a value contains fill-in placeholder text."""
    if not isinstance(value, str):
        return False
    
    value_lower = value.lower().strip()
    placeholders = [
        "[fill in", 
        "fill in", 
        "placeholder",
        "todo:",
        "tbd",
        "to be determined",
        "enter ",
        "add ",
        "insert ",
        "your ",
        "character name",
        "protagonist name",
        "location name",
        "faction name"
    ]
    
    return any(placeholder in value_lower for placeholder in placeholders)
