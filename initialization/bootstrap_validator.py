"""
Bootstrap validation pipeline for ensuring consistency between bootstrap-generated content and runtime configuration.

This module provides functions to extract content from bootstrap processes and validate
it against runtime configuration values to ensure narrative consistency.
"""

from __future__ import annotations

from typing import Any

import structlog

import config
from models.kg_models import CharacterProfile, WorldItem
from models.validation_utils import (
    BootstrapContentValidator,
    ConfigurationValidationError,
    get_validation_corrections,
    validate_bootstrap_consistency,
)


class BootstrapValidationResult:
    """
    Result object for bootstrap validation operations.

    This class represents the outcome of bootstrap validation, including
    whether validation passed and any warnings or errors encountered.
    """

    def __init__(self, is_valid: bool = True, warnings: list[str] | None = None):
        self.is_valid = is_valid
        self.warnings = warnings or []

    def add_error(self, error_message: str) -> None:
        """Add an error message and mark validation as invalid."""
        self.is_valid = False
        self.warnings.append(error_message)

    def add_warning(self, warning_message: str) -> None:
        """Add a warning message."""
        self.warnings.append(warning_message)

    def merge(self, other: BootstrapValidationResult) -> BootstrapValidationResult:
        """Merge this result with another validation result."""
        merged = BootstrapValidationResult(
            is_valid=self.is_valid and other.is_valid,
            warnings=self.warnings + other.warnings,
        )
        return merged


logger = structlog.get_logger(__name__)


class BootstrapValidationPipeline:
    """
    Pipeline for validating bootstrap-generated content against runtime configuration.

    This class manages the validation process for ensuring that bootstrap-generated
    content is consistent with runtime configuration values, preventing narrative
    inconsistencies in the novel generation process.
    """

    def __init__(self):
        self.logger = structlog.get_logger(__name__)
        self.validator = BootstrapContentValidator()

    async def validate_bootstrap_output(
        self,
        plot_outline: dict[str, Any],
        character_profiles: dict[str, CharacterProfile],
        world_building: dict[str, dict[str, WorldItem]],
        bootstrap_source: str = "bootstrap",
    ) -> tuple[bool, list[ConfigurationValidationError], dict[str, Any] | None]:
        """
        Validate bootstrap output against runtime configuration.

        Args:
            plot_outline: The plot outline generated by bootstrap
            character_profiles: Character profiles generated by bootstrap
            world_building: World building elements generated by bootstrap
            bootstrap_source: Source identifier for the bootstrap process

        Returns:
            Tuple of (is_valid, validation_errors, suggested_corrections)
        """
        self.logger.info(
            "Starting bootstrap validation pipeline", bootstrap_source=bootstrap_source
        )

        # Run validation
        is_valid, validation_errors = validate_bootstrap_consistency(
            plot_outline, character_profiles, world_building, bootstrap_source
        )

        # Get suggested corrections if validation failed
        suggested_corrections = None
        if not is_valid:
            suggested_corrections = get_validation_corrections(validation_errors)
            self.logger.warning(
                "Bootstrap validation failed, suggesting corrections",
                error_count=len(validation_errors),
                corrections=suggested_corrections,
            )

        return is_valid, validation_errors, suggested_corrections

    def extract_bootstrap_content_for_validation(
        self, bootstrap_result: dict[str, Any]
    ) -> tuple[
        dict[str, Any], dict[str, CharacterProfile], dict[str, dict[str, WorldItem]]
    ]:
        """
        Extract bootstrap content into validation-ready format.

        Args:
            bootstrap_result: Raw bootstrap result dictionary

        Returns:
            Tuple of (plot_outline, character_profiles, world_building)
        """
        plot_outline = bootstrap_result.get("plot_outline", {})
        character_profiles = bootstrap_result.get("character_profiles", {})
        world_building = bootstrap_result.get("world_building", {})

        # Ensure proper typing
        if not isinstance(plot_outline, dict):
            plot_outline = {}
        if not isinstance(character_profiles, dict):
            character_profiles = {}
        if not isinstance(world_building, dict):
            world_building = {}

        return plot_outline, character_profiles, world_building

    async def validate_and_correct_bootstrap(
        self, bootstrap_result: dict[str, Any], auto_correct: bool = False
    ) -> tuple[dict[str, Any], bool, list[ConfigurationValidationError]]:
        """
        Validate bootstrap result and optionally apply corrections.

        Args:
            bootstrap_result: Raw bootstrap result from bootstrap pipeline
            auto_correct: Whether to automatically apply corrections

        Returns:
            Tuple of (corrected_bootstrap_result, was_corrected, validation_errors)
        """
        # Extract content for validation
        plot_outline, character_profiles, world_building = (
            self.extract_bootstrap_content_for_validation(bootstrap_result)
        )

        # Validate the content
        is_valid, validation_errors, corrections = await self.validate_bootstrap_output(
            plot_outline, character_profiles, world_building
        )

        # Apply corrections if requested and available
        corrected_result = bootstrap_result.copy()
        was_corrected = False

        if not is_valid and auto_correct and corrections:
            was_corrected = self._apply_corrections(corrected_result, corrections)
            self.logger.info(
                "Applied automatic corrections to bootstrap result",
                corrections_applied=was_corrected,
            )

        return corrected_result, was_corrected, validation_errors

    def _apply_corrections(
        self, bootstrap_result: dict[str, Any], corrections: dict[str, Any]
    ) -> bool:
        """
        Apply suggested corrections to bootstrap result.

        Args:
            bootstrap_result: The bootstrap result to modify
            corrections: Suggested corrections from validation

        Returns:
            True if corrections were applied, False otherwise
        """
        corrected = False

        # Apply plot outline corrections
        if "plot_outline" in corrections and corrections["plot_outline"]:
            if "plot_outline" not in bootstrap_result:
                bootstrap_result["plot_outline"] = {}
            for key, value in corrections["plot_outline"].items():
                bootstrap_result["plot_outline"][key] = value
                corrected = True

        # Apply character profile corrections
        if "character_profiles" in corrections and corrections["character_profiles"]:
            if "character_profiles" not in bootstrap_result:
                bootstrap_result["character_profiles"] = {}
            for key, value in corrections["character_profiles"].items():
                bootstrap_result["character_profiles"][key] = value
                corrected = True

        # Apply world building corrections
        if "world_building" in corrections and corrections["world_building"]:
            if "world_building" not in bootstrap_result:
                bootstrap_result["world_building"] = {}
            for key, value in corrections["world_building"].items():
                bootstrap_result["world_building"][key] = value
                corrected = True

        return corrected

    def generate_validation_report(
        self,
        validation_errors: list[ConfigurationValidationError],
        corrections: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """
        Generate a detailed validation report.

        Args:
            validation_errors: List of validation errors found
            corrections: Suggested corrections (if any)

        Returns:
            Dictionary containing validation report
        """
        report = {
            "validation_timestamp": None,  # Will be set by caller
            "total_errors": len(validation_errors),
            "is_valid": len(validation_errors) == 0,
            "errors": [
                {
                    "field": error.field,
                    "message": error.message,
                    "bootstrap_value": str(error.bootstrap_value),
                    "runtime_value": str(error.runtime_value),
                }
                for error in validation_errors
            ],
            "corrections": corrections,
            "summary": self._generate_validation_summary(validation_errors),
        }

        return report

    def _generate_validation_summary(
        self, validation_errors: list[ConfigurationValidationError]
    ) -> str:
        """
        Generate a human-readable summary of validation results.

        Args:
            validation_errors: List of validation errors

        Returns:
            Summary string
        """
        if not validation_errors:
            return "Bootstrap validation passed: All content is consistent with runtime configuration."

        error_fields = [error.field for error in validation_errors]
        field_counts = {}
        for field in error_fields:
            field_counts[field] = field_counts.get(field, 0) + 1

        summary_parts = [
            f"Bootstrap validation failed with {len(validation_errors)} error(s):"
        ]

        for field, count in field_counts.items():
            summary_parts.append(f"  - {field}: {count} error(s)")

        return " ".join(summary_parts)


# Global pipeline instance
bootstrap_validation_pipeline = BootstrapValidationPipeline()


async def validate_bootstrap_result(
    bootstrap_result: dict[str, Any], auto_correct: bool = False
) -> tuple[dict[str, Any], bool, list[ConfigurationValidationError]]:
    """
    Convenience function to validate bootstrap result.

    Args:
        bootstrap_result: Raw bootstrap result from bootstrap pipeline
        auto_correct: Whether to automatically apply corrections

    Returns:
        Tuple of (corrected_bootstrap_result, was_corrected, validation_errors)
    """
    return await bootstrap_validation_pipeline.validate_and_correct_bootstrap(
        bootstrap_result, auto_correct
    )


def create_bootstrap_validation_report(
    validation_errors: list[ConfigurationValidationError],
    corrections: dict[str, Any] | None = None,
) -> dict[str, Any]:
    """
    Create a validation report for bootstrap results.

    Args:
        validation_errors: List of validation errors found
        corrections: Suggested corrections (if any)

    Returns:
        Dictionary containing validation report
    """
    return bootstrap_validation_pipeline.generate_validation_report(
        validation_errors, corrections
    )


async def validate_bootstrap_results(
    plot_outline: dict[str, Any],
    character_profiles: dict[str, CharacterProfile],
    world_building: dict[str, dict[str, WorldItem]],
    state_tracker: Any | None = None,
) -> BootstrapValidationResult:
    """
    Validate bootstrap results for consistency and completeness.

    This function performs comprehensive validation of bootstrap-generated content
    including cross-component consistency checks.

    Args:
        plot_outline: The plot outline dictionary
        character_profiles: Dictionary of character profiles
        world_building: Dictionary of world building elements
        state_tracker: Optional state tracker for validation

    Returns:
        BootstrapValidationResult with validation status and warnings
    """
    logger.info("Starting comprehensive bootstrap validation")

    validation_result = BootstrapValidationResult()

    # Use the new validation pipeline for consistency checks
    is_valid, validation_errors = validate_bootstrap_consistency(
        plot_outline, character_profiles, world_building
    )

    if not is_valid:
        for error in validation_errors:
            validation_result.add_error(error.message)

    # Add warnings for potential issues
    if not plot_outline.get("title"):
        validation_result.add_warning("Plot outline missing title")

    if not plot_outline.get("plot_points"):
        validation_result.add_warning("Plot outline missing plot points")

    if not character_profiles:
        validation_result.add_warning("No character profiles generated")

    if not world_building or not any(world_building.values()):
        validation_result.add_warning("No world building elements generated")

    logger.info(
        "Bootstrap validation completed",
        is_valid=validation_result.is_valid,
        warning_count=len(validation_result.warnings),
    )

    return validation_result


async def quick_validate_world(
    plot_outline: dict[str, Any],
    world_building: dict[str, dict[str, WorldItem]],
    state_tracker: Any | None = None,
) -> BootstrapValidationResult:
    """
    Quick validation focused on world building elements.

    Args:
        plot_outline: The plot outline dictionary
        world_building: Dictionary of world building elements
        state_tracker: Optional state tracker for validation

    Returns:
        BootstrapValidationResult with validation status and warnings
    """
    logger.info("Starting quick world validation")

    validation_result = BootstrapValidationResult()

    # Check for basic world structure
    if not world_building:
        validation_result.add_error("No world building elements generated")
        return validation_result

    # Check for required categories
    required_categories = ["locations", "society", "factions"]
    for category in required_categories:
        if category not in world_building:
            validation_result.add_warning(f"Missing world category: {category}")
        else:
            category_items = world_building[category]
            if not category_items:
                validation_result.add_warning(f"Empty world category: {category}")

    # Check for duplicate names within locations (requirement)
    if "locations" in world_building:
        locations = world_building["locations"]
        seen_names = set()
        duplicates = []

        for name, item in locations.items():
            if name in seen_names:
                duplicates.append(name)
            else:
                seen_names.add(name)

        for duplicate in duplicates:
            validation_result.add_error(f"Duplicate location name: {duplicate}")

    logger.info(
        "Quick world validation completed",
        is_valid=validation_result.is_valid,
        warning_count=len(validation_result.warnings),
    )

    return validation_result


async def quick_validate_characters(
    character_profiles: dict[str, CharacterProfile], state_tracker: Any | None = None
) -> BootstrapValidationResult:
    """
    Quick validation focused on character profiles.

    Args:
        character_profiles: Dictionary of character profiles
        state_tracker: Optional state tracker for validation

    Returns:
        BootstrapValidationResult with validation status and warnings
    """
    logger.info("Starting quick character validation")

    validation_result = BootstrapValidationResult()

    # Check for basic character structure
    if not character_profiles:
        validation_result.add_error("No character profiles generated")
        return validation_result

    # Check for protagonist
    expected_protagonist = config.DEFAULT_PROTAGONIST_NAME
    if expected_protagonist not in character_profiles:
        validation_result.add_error(
            f"Expected protagonist '{expected_protagonist}' not found"
        )
    else:
        protagonist_profile = character_profiles[expected_protagonist]
        if not protagonist_profile.name:
            validation_result.add_error("Protagonist profile missing name")

    # Check for duplicate character names
    seen_names = set()
    duplicates = []

    for name, profile in character_profiles.items():
        if name in seen_names:
            duplicates.append(name)
        else:
            seen_names.add(name)

    for duplicate in duplicates:
        validation_result.add_error(f"Duplicate character name: {duplicate}")

    logger.info(
        "Quick character validation completed",
        is_valid=validation_result.is_valid,
        warning_count=len(validation_result.warnings),
    )

    return validation_result
